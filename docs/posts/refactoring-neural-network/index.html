<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html lang="en"> <!--<![endif]-->
<head>

        <!-- Basic Page Needs
================================================== -->
        <meta charset="utf-8">
  <title>refactoring-neural-network</title>
        <meta name="description" content>
        <meta name="author" content>

        <!-- Fonts
================================================== -->
  <link href="http://fonts.googleapis.com/css?family=PT+Sans" rel="stylesheet" type="text/css">
  <link href="http://fonts.googleapis.com/css?family=PT+Serif" rel="stylesheet" type="text/css">

        <!-- Mobile Specific Metas
================================================== -->
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- CSS
================================================== -->
  <link rel="stylesheet" href="../../css/combined.css">

  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>

        <!--[if lt IE 9]>
                <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->

        <!-- Atom
        ================================================== -->
</head>
<body>

        <!-- Primary Page Layout
        ================================================== -->
  <div class="container">
  <div class="ten columns offset-by-three">
  <h1 style="margin-top: 40px"><a class="homelink" href="../../">The H2 Wiki</a></h1>
  <hr />
</div>
<div class="twelve columns offset-by-two">
  <h3>refactoring-neural-network</h3>
  <h1 id="refactoring-a-neural-network-implementation-in-haskell">Refactoring a neural network implementation in Haskell</h1>
<p>In 2015, <a href="http://www-cs-students.stanford.edu/~blynn/">Ben Lynn</a>
<a href="http://www-cs-students.stanford.edu/~blynn/haskell/brain.html">wrote a digit-classifying neural network in
Haskell</a>
that is remarkable in two ways. Firstly, he wrote the backpropagation
code by hand rather than relying on a framework. Secondly, he wrote
in a terse, point-free-heavy style that must have taken great mental
acuity. I came across Ben’s article on <a href="https://news.ycombinator.com/item?id=22315668">Hacker
News</a> where it was
suggested that, unfortunately, the style does not make it easy for the
unaccustomed reader to understand. Haskell makes refactoring safe and
convenient so let’s try and improve the readability of the code!</p>
<p>The original code appears in <a href="http://www-cs-students.stanford.edu/~blynn/haskell/brain.html">Ben’s
article</a>
and in <a href="https://github.com/blynn/morans/blob/bd02edc60a5048c3c109fe76adc1842691c664cd/morans.hs">a Github
repository</a>.
Let’s warm up by tackling something small. <code>zLayer</code> implements a
layer of a neural network.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">zLayer ::</span>[<span class="dt">Float</span>] <span class="ot">-&gt;</span> ([<span class="dt">Float</span>], [[<span class="dt">Float</span>]]) <span class="ot">-&gt;</span> [<span class="dt">Float</span>])</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>zLayer as (bs, wvs) <span class="ot">=</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">zipWith</span> (<span class="op">+</span>) bs <span class="op">$</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">zipWith</span> (<span class="op">*</span>) as <span class="op">&lt;$&gt;</span> wvs</span></code></pre></div>
<p>How does it work and what can we improve? Before we go any further I
want to be confident that the changes that I am making are correct.
Refactoring “<a href="https://en.wikipedia.org/wiki/Code_refactoring">is the process of restructuring existing code without
changing its external
behavior</a>” so to be
sure that I am not changing the external behaviour I will use a test
harness implemented with the excellent
<a href="https://github.com/hedgehogqa/haskell-hedgehog/">Hedgehog</a> property
testing library.</p>
<h2 id="hedgehog">Hedgehog</h2>
<p>I’m going to make an exact duplicate of the <code>zLayer</code> function called
<code>zLayer_new</code>. Then I will proceed to refactor it whilst a Hedgehog
check tests that the refactored version has exactly the same behaviour
as the original version. The Hedgehog code is</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Generate a random list</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ot">floatList ::</span> <span class="dt">MonadGen</span> m <span class="ot">=&gt;</span> m [<span class="dt">Float</span>]</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>floatList <span class="ot">=</span> Gen.list (Range.linear <span class="dv">0</span> <span class="dv">10</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>                     (Gen.float (Range.linearFrac (<span class="op">-</span><span class="dv">10</span>) <span class="dv">10</span>))</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- Generate random inputs for zLayer</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="ot">zLayerInput ::</span> <span class="dt">MonadGen</span> m <span class="ot">=&gt;</span> m ([<span class="dt">Float</span>], ([<span class="dt">Float</span>], [[<span class="dt">Float</span>]]))</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>zLayerInput <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  l1 <span class="ot">&lt;-</span> floatList</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  l2 <span class="ot">&lt;-</span> floatList</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  ll <span class="ot">&lt;-</span> Gen.list (Range.linear <span class="dv">0</span> <span class="dv">10</span>) floatList</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (l1, (l2, ll))</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="co">-- Check that my new implementation matches the original</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="ot">prop_same_zLayer ::</span> <span class="dt">Property</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>prop_same_zLayer <span class="ot">=</span> property <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>  (l1, t) <span class="ot">&lt;-</span> forAll zLayerInput</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>  zLayer_new l1 t <span class="op">===</span> zLayer l1 t</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="co">-- Run all the tests</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="ot">tests ::</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>tests <span class="ot">=</span> checkSequential <span class="op">$$</span>(discover)</span></code></pre></div>
<p><code>prop_same_zLayer</code> checks that the old and new implementation of
<code>zLayer</code> match. After every refactoring I’m going to run my Hedgehog
tests to ensure that I haven’t changed any behaviour.</p>
<h2 id="use-domain-specific-operators-and-types">Use domain-specific operators and types</h2>
<p>Now let’s get back to looking at <code>zLayer</code>. I notice that <code>zipWith (+)</code> performs the operation of adding two vectors. The vectors are
represented by lists of <code>Float</code>, and <code>zipWith (+)</code> adds the
corresponding entries in two lists, which is the same thing that
vector addition does. This suggests my first refactoring. I’m going
to define a new operator for vector addition.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.+) ::</span>[<span class="dt">Float</span>] <span class="ot">-&gt;</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> [<span class="dt">Float</span>])</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>(<span class="op">.+</span>) <span class="ot">=</span> <span class="fu">zipWith</span> (<span class="op">+</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="ot">zLayer_new ::</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> ([<span class="dt">Float</span>], [[<span class="dt">Float</span>]]) <span class="ot">-&gt;</span> [<span class="dt">Float</span>]</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>zLayer_new as (bs, wvs) <span class="ot">=</span> bs <span class="op">.+</span> (<span class="fu">sum</span> <span class="op">.</span> <span class="fu">zipWith</span> (<span class="op">*</span>) as <span class="op">&lt;$&gt;</span> wvs)</span></code></pre></div>
<p>If <code>zipWith (+)</code> is vector addition then what is <code>zipWith (*)</code>?
Componentwise multiplication followed by summing the components is the
definition of the dot product of two vectors so I’ll introduce a <code>dot</code>
operation.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">dot ::</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> <span class="dt">Float</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>dot v1 v2 <span class="ot">=</span> <span class="fu">sum</span> (<span class="fu">zipWith</span> (<span class="op">*</span>) v1 v2)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="ot">zLayer_new ::</span>[<span class="dt">Float</span>] <span class="ot">-&gt;</span> ([<span class="dt">Float</span>], [[<span class="dt">Float</span>]]) <span class="ot">-&gt;</span> [<span class="dt">Float</span>]</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>zLayer_new as (bs, wvs) <span class="ot">=</span> bs <span class="op">.+</span> (dot as <span class="op">&lt;$&gt;</span> wvs)</span></code></pre></div>
<p>What about this <code>&lt;$&gt;</code> thing? That’s another name for <code>fmap</code>, and it’s
mapping the <code>dot as</code> function across the list-of-lists called <code>wvs</code>.
What does that mean? One way of interpreting vector-matrix
multiplication is that it maps the dot operation across the columns of
a matrix. Therefore I add a “vector-matrix multiplication” operation,
<code>.*</code>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.*) ::</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> [[<span class="dt">Float</span>]] <span class="ot">-&gt;</span> [<span class="dt">Float</span>]</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>v <span class="op">.*</span> m <span class="ot">=</span> dot v <span class="op">&lt;$&gt;</span> m</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="ot">zLayer_new ::</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> ([<span class="dt">Float</span>], [[<span class="dt">Float</span>]]) <span class="ot">-&gt;</span> [<span class="dt">Float</span>]</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>zLayer_new as (bs, wvs) <span class="ot">=</span> bs <span class="op">.+</span> (as <span class="op">.*</span> wvs)</span></code></pre></div>
<p>I’m going to take advantage of the knowledge gained during refactoring
to introduce some type synonyms.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Vector</span> <span class="ot">=</span> [<span class="dt">Float</span>]</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Matrix</span> <span class="ot">=</span> [[<span class="dt">Float</span>]]</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="ot">zLayer_new ::</span> <span class="dt">Vector</span> <span class="ot">-&gt;</span> (<span class="dt">Vector</span>, <span class="dt">Matrix</span>) <span class="ot">-&gt;</span> <span class="dt">Vector</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>zLayer_new as (bs, wvs) <span class="ot">=</span> bs <span class="op">.+</span> (as <span class="op">.*</span> wvs)</span></code></pre></div>
<p>Compared to the original <code>zLayer</code> (reproduced below) we have made a
big improvement. There is no <code>sum</code>, no <code>zipWith</code> and no
non-mathematical operator. <code>zLayer</code> is an operation which multiplies
by a matrix and then adds a vector. It’s as simple as A * B + C.</p>
<pre><code>zLayer as (bs, wvs) = zipWith (+) bs $ sum . zipWith (*) as &lt;$&gt; wvs</code></pre>
<h2 id="introduce-new-variables-when-it-helps">Introduce new variables when it helps</h2>
<p>I’m pleased with how <code>zLayer</code> looks so I will go straight to the next
mathematical function in the module, called <code>feed</code>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">feed_new ::</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> [([<span class="dt">Float</span>], [[<span class="dt">Float</span>]])] <span class="ot">-&gt;</span> [<span class="dt">Float</span>]</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>feed <span class="ot">=</span> foldl' (((relu <span class="op">&lt;$&gt;</span>) <span class="op">.</span> ) <span class="op">.</span> zLayer)</span></code></pre></div>
<p>The type is similar to that of <code>zLayer</code> but I’m not going to use my
<code>Vector</code> and <code>Matrix</code> synonyms until I’m sure that they are indeed
what the lists of <code>Float</code>s are representing. (I’ll keep adding
Hedgehog equivalence tests but won’t show any more of the Hedgehog
code in this article because it’s completely standard testing code.)</p>
<p>The use of <code>&lt;$&gt;</code> and <code>.</code> is mysterious. I know that <code>&lt;$&gt;</code> is <code>fmap</code>
and <code>.</code> is function composition but that doesn’t help me understand
what they are doing. Use of function composition is popular in
Haskell to avoid naming intermediate variables. Sometimes avoiding
intermediate variables helps readability but here I think it hurts
readability so I’m going to reintroduce them.</p>
<p>I’m going to expand <code>.</code> by replacing it with its definition. I know
that the first argument of <code>zLayer</code> is a vector so I choose the name
<code>v</code> for the variable of the lambda. Naturally, after each refactoring
I run my Hedgehog tests to check that <code>feed_new</code> has the same
behaviour as <code>feed</code>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>feed_new <span class="ot">=</span> foldl' (\v <span class="ot">-&gt;</span> ((relu <span class="op">&lt;$&gt;</span>) <span class="op">.</span> ) (zLayer v))</span></code></pre></div>
<p>That’s a good start. Then I apply the <code>.</code> section</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>feed_new <span class="ot">=</span> foldl' (\v <span class="ot">-&gt;</span> (relu <span class="op">&lt;$&gt;</span>) <span class="op">.</span> zLayer v)</span></code></pre></div>
<p>and I can inline the definition of <code>.</code> again. The second argument of
<code>zLayer</code> is a <code>(Vector, Matrix)</code> so I choose the name <code>vm</code> for
the lambda.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>feed_new <span class="ot">=</span> foldl' (\v vm <span class="ot">-&gt;</span> relu <span class="op">&lt;$&gt;</span> zLayer v vm)</span></code></pre></div>
<p>This is <em>much</em> better! Just from knowing what a left fold is we can
understand that <code>feed</code> starts with a vector and then successively
applies <code>zLayer</code> and <code>relu</code> for each <code>vm</code> in a list. At this point I
know it’s fine to use the type synonyms I defined earlier. I’m also
going to use my domain knowledge to define a new type synonym,
<code>Layer</code>. A neural network consists of a sequence of <code>Layer</code>s, each
layer comprising a <code>Vector</code> and <code>Matrix</code>. We started with</p>
<pre><code>feed = foldl' (((relu &lt;$&gt;) . ) . zLayer)</code></pre>
<p>and we ended with</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Layer</span> <span class="ot">=</span> (<span class="dt">Vector</span>, <span class="dt">Matrix</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="ot">feed_new ::</span> <span class="dt">Vector</span> <span class="ot">-&gt;</span> [<span class="dt">Layer</span>] <span class="ot">-&gt;</span> <span class="dt">Vector</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>feed_new <span class="ot">=</span> foldl' (\v vm <span class="ot">-&gt;</span> relu <span class="op">&lt;$&gt;</span> zLayer vm m)</span></code></pre></div>
<p>That is, <code>feed</code> takes a vector, applies a sequence of neural network
layers and returns the resulting vector.</p>
<h2 id="make-properties-structural">Make properties structural</h2>
<p>Right, onto the next candidate, <code>revaz</code>.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">revaz_new ::</span> [<span class="dt">Float</span>]</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> [([<span class="dt">Float</span>], [[<span class="dt">Float</span>]])]</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> ([[<span class="dt">Float</span>]], [[<span class="dt">Float</span>]])</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>revaz_new xs <span class="ot">=</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  foldl' (\(avs<span class="op">@</span>(av<span class="op">:</span>_), zs) (bs, wms) <span class="ot">-&gt;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>             <span class="kw">let</span> zs' <span class="ot">=</span> zLayer av (bs, wms)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>             <span class="kw">in</span> ((relu <span class="op">&lt;$&gt;</span> zs')<span class="op">:</span>avs, zs'<span class="op">:</span>zs)) ([xs], [])</span></code></pre></div>
<p>Something looks suspicious here. There is a partial pattern match on a
list. What happens if the list is empty? To our relief we can see
that the list starts non-empty (it is <code>[xs]</code>) and it only ever grows
(in each iteration it has <code>relu &lt;$&gt; zs'</code> consed onto the front). This
is all very well but personally I’d prefer that it was the compiler,
rather than my own reasoning, that reassures me about safe program
behaviour. Let’s pass the “head of the list” in a separate tuple
component. We’ll have to cons the final “head of the list” onto the
list after the <code>foldl'</code> has completed.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>revaz_new xs ys <span class="ot">=</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (av, avs, zs) <span class="ot">=</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>        foldl' (\(av, avs, zs) (bs, wms) <span class="ot">-&gt;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">let</span> zs' <span class="ot">=</span> zLayer av (bs, wms)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">in</span> (relu <span class="op">&lt;$&gt;</span> zs', av<span class="op">:</span>avs, zs'<span class="op">:</span>zs))</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>             (xs, [], [])</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>             ys</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> (av<span class="op">:</span>avs, zs)</span></code></pre></div>
<p>This looks a bit more messy than before but let’s keep going and see
where we can get. The next thing I notice is that each iteration
around the loop we stick one new element onto the front of each of
<code>avs</code> and <code>zs</code>, that is, at all stages <code>avs</code> and <code>zs</code> are exactly the
same length. Let’s make this property structural by building one list
of pairs instead of two lists. Again, we’ll have to postprocess the
result of <code>foldl'</code>, this time unzipping one list into two lists.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>revaz_new xs ys <span class="ot">=</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (av, avs_zs) <span class="ot">=</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>        foldl' (\(av, avs_zs) (bs, wms) <span class="ot">-&gt;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">let</span> zs' <span class="ot">=</span> zLayer av (bs, wms)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">in</span> (relu <span class="op">&lt;$&gt;</span> zs', (av, zs')<span class="op">:</span>avs_zs))</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>             (xs, [])</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>             ys</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>      (avs, zs) <span class="ot">=</span> <span class="fu">unzip</span> avs_zs</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> (av<span class="op">:</span>avs, zs)</span></code></pre></div>
<p>Now that I can see what’s going on a bit more clearly I can add type
synonyms to the signature. Importantly, I can see that the
<code>[[Float]]</code>s are not <code>Matrix</code>s, rather they are lists of <code>Vector</code>s!
It’s good that I was cautious and didn’t just substitute type synonyms
blindly.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">revaz_new ::</span> <span class="dt">Vector</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> [<span class="dt">Layer</span>]</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> ([<span class="dt">Vector</span>], [<span class="dt">Vector</span>])</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>revaz_new xs ys <span class="ot">=</span> (av<span class="op">:</span>avs, zs)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> (avs, zs) <span class="ot">=</span> <span class="fu">unzip</span> avs_zs</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>        (av, avs_zs) <span class="ot">=</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>          foldl' (\(av, avs_zs) (bs, wms) <span class="ot">-&gt;</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">let</span> zs' <span class="ot">=</span> zLayer av (bs, wms)</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">in</span> (relu <span class="op">&lt;$&gt;</span> zs', (av, zs')<span class="op">:</span>avs_zs))</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>                 (xs, [])</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>                 ys</span></code></pre></div>
<p>Finally I can neaten this a little by noticing that I don’t need to
unpack the <code>(bs, wms)</code> tuple.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">revaz_new ::</span> <span class="dt">Vector</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> [<span class="dt">Layer</span>]</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> ([<span class="dt">Vector</span>], [<span class="dt">Vector</span>])</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>revaz_new xs ys <span class="ot">=</span> (av<span class="op">:</span>avs, zs)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> (avs, zs) <span class="ot">=</span> <span class="fu">unzip</span> avs_zs</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>        (av, avs_zs) <span class="ot">=</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>          foldl' (\(av, avs_zs) t <span class="ot">-&gt;</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">let</span> zs' <span class="ot">=</span> zLayer av t</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">in</span> (relu <span class="op">&lt;$&gt;</span> zs', (av, zs')<span class="op">:</span>avs_zs))</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>                 (xs, [])</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>                 ys</span></code></pre></div>
<p>I find this marginally clearer than what we started with but not
ideal. Let’s move on and we’ll come back to <code>revaz</code> later.</p>
<h2 id="try-to-avoid-explicit-recursion">Try to avoid explicit recursion</h2>
<p>Next up, this behemoth.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>deltas xv yv layers <span class="ot">=</span> <span class="kw">let</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  (avs<span class="op">@</span>(av<span class="op">:</span>_), zv<span class="op">:</span>zvs) <span class="ot">=</span> revaz xv layers</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  delta0 <span class="ot">=</span> <span class="fu">zipWith</span> (<span class="op">*</span>) (<span class="fu">zipWith</span> dCost av yv) (relu' <span class="op">&lt;$&gt;</span> zv)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> (<span class="fu">reverse</span> avs, f (transpose <span class="op">.</span> <span class="fu">snd</span> <span class="op">&lt;$&gt;</span> <span class="fu">reverse</span> layers) zvs [delta0]) <span class="kw">where</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    f _ [] dvs <span class="ot">=</span> dvs</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    f (wm<span class="op">:</span>wms) (zv<span class="op">:</span>zvs) dvs<span class="op">@</span>(dv<span class="op">:</span>_) <span class="ot">=</span> f wms zvs <span class="op">$</span> (<span class="op">:</span>dvs) <span class="op">$</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>      <span class="fu">zipWith</span> (<span class="op">*</span>) [<span class="fu">sum</span> <span class="op">$</span> <span class="fu">zipWith</span> (<span class="op">*</span>) row dv <span class="op">|</span> row <span class="ot">&lt;-</span> wm] (relu' <span class="op">&lt;$&gt;</span> zv)</span></code></pre></div>
<p>The Hedgehog equivalence test requires some care. As you can see from
the pattern match on the result of <code>revaz</code>, <code>deltas</code> expects both the
lists in the pair to be non-empty. The first one, <code>avs</code>, is
guaranteed to be non-empty (we can conveniently see this from our
refactored version of <code>revaz</code>: it has <code>av</code> on the front). What about
the second one, <code>zvs</code>? By inspecting <code>revaz</code> we can see that the
length of <code>zvs</code> is the same as the length of the list-of-<code>Vector</code>s
input to <code>revaz</code>. Therefore we need <code>layers</code> to be non-empty. If we
tell Hedgehog to generate input data satisfying this condition then
all is well.</p>
<p>The first thing in <code>deltas</code> that I want to tackle is the local
function <code>f</code>. It looks complicated, involving <code>zipWith</code>, a <code>:</code>
section and a list comprehension. Even worse, it’s a recursive
function! Even though recursion is typically thought of as the
bread-and-butter of functional programming, unrestricted recursion is
almost as bad for code comprehensibility as GOTO is in imperative
programming. We ought to seek to use recursion combinators such as
maps, folds, scans, etc. in preference to direct recursion.</p>
<p>Let’s tackle the recursion shortly. I see something I can do straight
away, which is to use the <code>dot</code> product operator that I defined
earlier.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>f (wm<span class="op">:</span>wms) (zv<span class="op">:</span>zvs) dvs<span class="op">@</span>(dv<span class="op">:</span>_) <span class="ot">=</span> f wms zvs <span class="op">$</span> (<span class="op">:</span>dvs) <span class="op">$</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>   <span class="fu">zipWith</span> (<span class="op">*</span>) [dot row dv <span class="op">|</span> row <span class="ot">&lt;-</span> wm] (relu' <span class="op">&lt;$&gt;</span> zv)</span></code></pre></div>
<p><code>dot</code> is commutative, so I can write <code>dot row dv</code> as <code>dot dv row</code>.
Then I can conveniently rewrite the list comprehension as an <code>fmap</code>.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>f (wm<span class="op">:</span>wms) (zv<span class="op">:</span>zvs) dvs<span class="op">@</span>(dv<span class="op">:</span>_) <span class="ot">=</span> f wms zvs <span class="op">$</span> (<span class="op">:</span>dvs) <span class="op">$</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">zipWith</span> (<span class="op">*</span>) (<span class="fu">fmap</span> (dot dv) wm) (relu' <span class="op">&lt;$&gt;</span> zv)</span></code></pre></div>
<p>Recalling that <code>&lt;$&gt;</code> is an alias for <code>fmap</code> we see that the list
comprehension was just doing a vector-matrix product all along!</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>f (wm<span class="op">:</span>wms) (zv<span class="op">:</span>zvs) dvs<span class="op">@</span>(dv<span class="op">:</span>_) <span class="ot">=</span> f wms zvs <span class="op">$</span> (<span class="op">:</span>dvs) <span class="op">$</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">zipWith</span> (<span class="op">*</span>) (dv <span class="op">.*</span> wm) (relu' <span class="op">&lt;$&gt;</span> zv)</span></code></pre></div>
<p>This is looking a lot better already, but still not good. There’s a
mysterious <code>:</code> section there. Let’s just inline it.</p>
<pre><code>f (wm:wms) (zv:zvs) dvs@(dv:_) = f wms zvs $
  zipWith (*) (dv .* wm) (relu' &lt;$&gt; zv) : dvs</code></pre>
<p>That looks less mysterious and the line is now readable. The function
<code>f</code> is still mysterious though. What’s it doing? As in <code>revaz</code>, it
unconditionally inspects the first element, <code>dv</code>, of a list, so let’s
pass that in as a separate argument.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> (<span class="fu">reverse</span> avs,</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>      f (transpose <span class="op">.</span> <span class="fu">snd</span> <span class="op">&lt;$&gt;</span> <span class="fu">reverse</span> layers) zvs delta0 []) <span class="kw">where</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    f _ [] dv dvs <span class="ot">=</span> dv<span class="op">:</span>dvs</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    f (wm<span class="op">:</span>wms) (zv<span class="op">:</span>zvs) dv dvs <span class="ot">=</span> f wms zvs</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>      (<span class="fu">zipWith</span> (<span class="op">*</span>) (dv <span class="op">.*</span> wm) (relu' <span class="op">&lt;$&gt;</span> zv)) (dv<span class="op">:</span>dvs)</span></code></pre></div>
<p>Next I notice that <code>f</code> is iterating over two lists at the same time,
taking one element off each during each iteration. It may as well
iterate over the <code>zip</code> of the two lists instead! Why is that a good
thing to do? Because <code>f</code> is now nearly a left fold. Let’s make it
closer to left fold by packaging the <code>dv</code> and <code>dvs</code> together in a
tuple</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">in</span> (<span class="fu">reverse</span> avs,</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    f (<span class="fu">zip</span> (transpose <span class="op">.</span> <span class="fu">snd</span> <span class="op">&lt;$&gt;</span> <span class="fu">reverse</span> layers) zvs) (delta0, []))</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="kw">where</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  f [] (dv, dvs) <span class="ot">=</span> dv<span class="op">:</span>dvs</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>  f ((wm, zv)<span class="op">:</span>wms_zvs) (dv, dvs) <span class="ot">=</span> f wms_zvs</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    (<span class="fu">zipWith</span> (<span class="op">*</span>) (dv <span class="op">.*</span> wm) (relu' <span class="op">&lt;$&gt;</span> zv), dv<span class="op">:</span>dvs)</span></code></pre></div>
<p>and combine <code>dv</code> and <code>dvs</code> after the recursive function (now called
<code>g</code>) has returned, rather than in the base case.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>f l t <span class="ot">=</span> <span class="kw">let</span> (dv, dvs) <span class="ot">=</span> g l t <span class="kw">in</span> dv<span class="op">:</span>dvs</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>g [] (dv, dvs) <span class="ot">=</span> (dv, dvs)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>g ((wm, zv)<span class="op">:</span>wms_zvs) (dv, dvs) <span class="ot">=</span> g wms_zvs</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>  (<span class="fu">zipWith</span> (<span class="op">*</span>) (dv <span class="op">.*</span> wm) (relu' <span class="op">&lt;$&gt;</span> zv), dv<span class="op">:</span>dvs)</span></code></pre></div>
<p>Now <code>g</code> <em>is</em> a left fold!</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>g l t <span class="ot">=</span> foldl' h t l</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">where</span> h (dv, dvs) (wm, zv) <span class="ot">=</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>           (<span class="fu">zipWith</span> (<span class="op">*</span>) (dv <span class="op">.*</span> wm) (relu' <span class="op">&lt;$&gt;</span> zv), dv<span class="op">:</span>dvs)</span></code></pre></div>
<p>Shuffling some arguments around and tidying gives us</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>f l t <span class="ot">=</span> <span class="kw">let</span> (dv, dvs) <span class="ot">=</span> g t l <span class="kw">in</span> dv<span class="op">:</span>dvs</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>g <span class="ot">=</span> foldl' (\(dv, dvs) (wm, zv) <span class="ot">-&gt;</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>      (<span class="fu">zipWith</span> (<span class="op">*</span>) (dv <span class="op">.*</span> wm) (relu' <span class="op">&lt;$&gt;</span> zv), dv<span class="op">:</span>dvs))</span></code></pre></div>
<p>This is already looking <em>much</em> better than the <code>f</code> that we started
with, but additionally, something excellent has occurred. We can see
that both <code>revaz_new</code> and <code>g</code> employ the same sort of recursion
pattern. They both iterate over a list with a state and push one new
value onto the front of a list each iteration (treating the list as a
sort of stack). We can capture this recursion pattern by abstracting
the behaviour out into a recursion combinator! I’m going to call it
<code>revMapWithState</code>, a name that describes fairly well what it does.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ot">revMapWithState ::</span> (state <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (state, stack))</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>                <span class="ot">-&gt;</span> (state, [stack])</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>                <span class="ot">-&gt;</span> [a]</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>                <span class="ot">-&gt;</span> (state, [stack])</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>revMapWithState f <span class="ot">=</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>  foldl' (\(state, stack) item <span class="ot">-&gt;</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>     <span class="kw">let</span> (nextState, nextStack) <span class="ot">=</span> f state item</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> (nextState, nextStack<span class="op">:</span>stack))</span></code></pre></div>
<p><code>revMapWithState</code> captures the sort of recursion that’s happening in
<code>revaz_new</code> and <code>g</code>, and we can rewrite both of them in terms of it.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">revaz_new ::</span> <span class="dt">Vector</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> [<span class="dt">Layer</span>]</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> ([<span class="dt">Vector</span>], [<span class="dt">Vector</span>])</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>revaz_new xs ys <span class="ot">=</span> (av<span class="op">:</span>avs, zs)</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> (avs, zs) <span class="ot">=</span> <span class="fu">unzip</span> avs_zs</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>        (av, avs_zs) <span class="ot">=</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>          revMapWithState (\av t <span class="ot">-&gt;</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">let</span> zs' <span class="ot">=</span> zLayer av t</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">in</span> (relu <span class="op">&lt;$&gt;</span> zs', (av, zs')))</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>                 xs</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>                 ys</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>g <span class="ot">=</span> revMapWithState (\dv (wm, zv) <span class="ot">-&gt;</span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>      (<span class="fu">zipWith</span> (<span class="op">*</span>) (dv <span class="op">.*</span> wm) (relu' <span class="op">&lt;$&gt;</span> zv), dv))</span></code></pre></div>
<p>The benefit of using <code>revMapWithState</code> is that it takes care of the
result stack for us and we only have to produce the next element of
the stack and the next state.</p>
<p>Looking at where we are now with <code>deltas_new</code>, I can see that
expressions of the form <code>zipWith (*) _ (relu' &lt;$&gt; _)</code> appear twice.
Twice <a href="https://en.wikipedia.org/wiki/Rule_of_three_(computer_programming)">isn’t quite enough on its
own</a>
to make us want to pull it out into a separate function, but my domain
knowledge that this is the backpropagator for
<a href="https://en.wikipedia.org/wiki/Rectifier_(neural_networks)"><code>relu</code></a>
convinces me that this is the right thing to do. Now we can tidy up,
using a little domain knowledge in naming the variables, to achieve</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="ot">dRelu ::</span> <span class="dt">Vector</span> <span class="ot">-&gt;</span> <span class="dt">Vector</span> <span class="ot">-&gt;</span> <span class="dt">Vector</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>dRelu a b <span class="ot">=</span> <span class="fu">zipWith</span> (<span class="op">*</span>) a (relu' <span class="op">&lt;$&gt;</span> b)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="ot">deltas_new ::</span> <span class="dt">Vector</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>           <span class="ot">-&gt;</span> <span class="dt">Vector</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>           <span class="ot">-&gt;</span> [<span class="dt">Layer</span>]</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>           <span class="ot">-&gt;</span> ([<span class="dt">Vector</span>], [<span class="dt">Vector</span>])</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>deltas_new xv yv layers <span class="ot">=</span> (<span class="fu">reverse</span> avs, dv<span class="op">:</span>dvs) <span class="kw">where</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>  (avs<span class="op">@</span>(av<span class="op">:</span>_), zv<span class="op">:</span>zvs) <span class="ot">=</span> revaz xv layers</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>  dv0 <span class="ot">=</span> dRelu (<span class="fu">zipWith</span> dCost av yv) zv</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>  matrices <span class="ot">=</span> <span class="fu">map</span> <span class="fu">snd</span> layers</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>  (dv, dvs) <span class="ot">=</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>    backProp dv0 (<span class="fu">zip</span> (<span class="fu">map</span> transpose (<span class="fu">reverse</span> matrices)) zvs)</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>  backProp <span class="ot">=</span></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>    revMapWithState (\dv (wm, zv) <span class="ot">-&gt;</span> (dRelu (dv <span class="op">.*</span> wm) zv, dv))</span></code></pre></div>
<p>It’s still not <em>easy</em> to read, but the reason that it is hard to read
has changed. It is now hard to read because it’s a hand-written
backpropagation routine for a deep neural network. It used to be hard
to read because it contained deeply-nested expressions,
non-mathematical symbols and an ad hoc recursive function. I think
that the refactored version is about as easy to read as the overall
design of this module will allow.</p>
<p>We’ve improved the readability of the original program significantly
so I’ll stop here. Whilst I think we have improved Ben’s program I’m
also impressed that he was able to write it the way he did in the
first place! I couldn’t have kept all the necessary details in my
head. There’s more we could refactor but this article already gives
us plenty to chew on. If you enjoyed this article and you’d like me
to continue refactoring in a future article then please and <a href="http://web.jaguarpaw.co.uk/~tom/contact/">let me
know</a>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Haskell makes refactoring a breeze. Higher-order functions and
expression-based style make it possible to slice and splice code in
fine grained ways and easily capture repeated patterns.
<a href="https://github.com/hedgehogqa/haskell-hedgehog/">Hedgehog</a> allows us
to <a href="http://wiki.c2.com/?RefactorMercilessly">refactor mercilessly</a>
whilst remaining confident that we are not changing program behaviour.
The examples of refactorings we saw that make code easier to
understand were: using domain-specific operators and types, introducing
new variable names when it helps readability, converting program
properties (which can’t be checked by a type checker) into program
structure (which can) and avoiding explicit recursion where possible.</p>
<p>If you come across Haskell code in the wild that you can’t easily read
then do not be disheartened. Maybe it can be refactored using the
techniques described in this article.</p>
<h3 id="other-examples-of-refactoring-haskell">Other examples of refactoring Haskell</h3>
<p>See also my other worked examples of refactoring in Haskell:</p>
<ul>
<li><p><a href="../good-design-and-type-safety-in-yahtzee/">Good design and type safety in
Yahtzee</a></p></li>
<li><p><a href="../using-brain-less-refactoring-yahtzee/">Using our brain less in refactoring
Yahtzee</a></p></li>
</ul>
</div>
<hr>

  </div>

<!-- End Document
================================================== -->
</body>
</html>
