<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html lang="en"> <!--<![endif]-->
<head>

        <!-- Basic Page Needs
================================================== -->
        <meta charset="utf-8">
  <title>foldl-traverses-state-foldr-traverses-anything</title>
        <meta name="description" content>
        <meta name="author" content>

        <!-- Fonts
================================================== -->
  <link href="http://fonts.googleapis.com/css?family=PT+Sans" rel="stylesheet" type="text/css">
  <link href="http://fonts.googleapis.com/css?family=PT+Serif" rel="stylesheet" type="text/css">

        <!-- Mobile Specific Metas
================================================== -->
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- CSS
================================================== -->
  <link rel="stylesheet" href="../../css/combined.css">

  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>

        <!--[if lt IE 9]>
                <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->

        <!-- Atom
        ================================================== -->
</head>
<body>

        <!-- Primary Page Layout
        ================================================== -->
  <div class="container">
  <div class="ten columns offset-by-three">
  <h1 style="margin-top: 40px"><a class="homelink" href="../../">The H2 Wiki</a></h1>
  <hr />
</div>
<div class="twelve columns offset-by-two">
  <h3>foldl-traverses-state-foldr-traverses-anything</h3>
  <h1 id="foldl-traverses-with-state-foldr-traverses-with-anything"><code>foldl</code> traverses with <code>State</code>, <code>foldr</code> traverses with anything</h1>
<h2 id="whether-to-foldl-or-foldr">Whether to <code>foldl</code> or <code>foldr</code>?</h2>
<p>Avi Press gave <a href="https://www.youtube.com/watch?v=qw4S_6FXsp4">an excellent
talk</a> at <em>Scale By the
Bay 2023</em> about difficulties using Haskell at a startup. <a href="https://www.youtube.com/watch?v=qw4S_6FXsp4&amp;t=1377s">He mentions
that</a> even
experienced Haskellers don’t always know how to use fundamental parts
of the language. In particular,</p>
<blockquote>
<p>even experienced Haskell engineers aren’t always going to know
whether to
<a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Prelude.html#v:foldl"><code>foldl</code></a>
or
<a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Prelude.html#v:foldr"><code>foldr</code></a>.</p>
</blockquote>
<p>In this article I’ll deduce a firm rule that allows you to make the
correct choice. I will stick to the versions of these functions that
operate on lists; their generalization to
<a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Prelude.html#t:Foldable"><code>Foldable</code></a>
warrants a separate article. In summary, the answer is</p>
<ul>
<li>use
<a href="https://www.stackage.org/haddock/lts-22.3/base-4.18.1.0/Data-Foldable.html#v:foldl-39-"><code>foldl'</code></a>,
never use <code>foldl</code></li>
<li>prefer <code>foldl'</code> over <code>foldr</code> whenever possible</li>
<li>alternatively, consider just using
<a href="https://www.stackage.org/haddock/lts-22.3/base-4.18.1.0/Data-Foldable.html#v:for_"><code>for_</code></a></li>
</ul>
<p>But why? Let’s see, by examining what these functions do.</p>
<h2 id="the-definitions">The definitions</h2>
<p>We’ll work with the traditional definitions of <code>foldl</code> and <code>foldr</code>,
given below. The implementations in <code>base</code> are more complicated, for
performance reasons, but the reasoning in this article applies to them too.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldl</span><span class="ot"> ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">foldl</span> f z [] <span class="ot">=</span> z</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">foldl</span> f z (a <span class="op">:</span> as) <span class="ot">=</span> <span class="fu">foldl</span> f (f z a) as</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span> f z [] <span class="ot">=</span> z</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span> f z (a <span class="op">:</span> as) <span class="ot">=</span> f a (<span class="fu">foldr</span> f z as)</span></code></pre></div>
<h3 id="whats-the-difference">What’s the difference?</h3>
<p>Ostensibly, the difference between <code>foldl</code> and <code>foldr</code> is the that
former “associates a binary operation to the left” and the latter
“associates a binary operation to the right”, as follows.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldl</span> (<span class="op">**</span>) z [x1, x2, <span class="op">...</span>, xn] <span class="op">==</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  (<span class="op">...</span>((z <span class="op">**</span> x1) <span class="op">**</span> x2) <span class="op">**...</span>) <span class="op">**</span> xn</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span> (<span class="op">**</span>) z [x1, x2, <span class="op">...</span>, xn] <span class="op">==</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  x1 <span class="op">**</span> (x2 <span class="op">**</span> <span class="op">...</span> (xn <span class="op">**</span> z)<span class="op">...</span>)</span></code></pre></div>
<p>Those are indeed descriptions of the calculated results, but that
distinction is not particularly important. If we only care about the
result then it’s easy enough to convert between <code>foldl</code> and <code>foldr</code>,
as shown below. The important difference is <em>how</em> they calculate the
result; the conversion below does not preserve behaviour. For example,
<code>foldl (-) 0</code> calculates a sequence of subtractions in constant
space<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>; <code>foldr (flip (-)) 0</code> uses <em>O(n)</em> space.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldl</span> f z <span class="op">==</span> <span class="fu">foldr</span> (<span class="fu">flip</span> f) z <span class="op">.</span> <span class="fu">reverse</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span> f z <span class="op">==</span> <span class="fu">foldl</span> (<span class="fu">flip</span> f) z <span class="op">.</span> <span class="fu">reverse</span></span></code></pre></div>
<p>We will apply our analysis of <code>foldl</code> to its strict counterpart,
<code>foldl'</code>, too.</p>
<h2 id="foldl-traverses-with-state"><code>foldl</code> traverses with <code>State</code></h2>
<p>So what is the precise difference between how the two folds calculate
their results? Consider this: suppose we didn’t have <code>foldl</code>, we only
had
<a href="https://www.stackage.org/haddock/lts-22.3/base-4.18.1.0/Prelude.html#v:traverse"><code>traverse</code></a>
for
<a href="https://www.stackage.org/haddock/lts-22.3/transformers-0.6.1.0/Control-Monad-Trans-State-Strict.html#t:State"><code>State</code></a>.
Nonetheless, we could recover <code>foldl</code>! (In fact we only need
<a href="https://www.stackage.org/haddock/lts-22.3/base-4.18.1.0/Data-Foldable.html#v:traverse_"><code>traverse_</code></a>,
a weaker form of <code>traverse</code>, and in these examples we’ll use <code>for_ = flip traverse_</code> for syntactic convenience.) The example below shows
how. It converts a function that performs <code>for_</code> (restricted to
<code>State</code>) into a function that performs <code>foldl</code>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foldlFromForState ::</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">forall</span> a b<span class="op">.</span> [b] <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> <span class="dt">State</span> a ()) <span class="ot">-&gt;</span> <span class="dt">State</span> a ()) <span class="ot">-&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">forall</span> a b<span class="op">.</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">-&gt;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  [b] <span class="ot">-&gt;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  a</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>foldlFromForState for_ f z bs <span class="ot">=</span> <span class="fu">flip</span> evalState z <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  for_ bs <span class="op">$</span> \b <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    a <span class="ot">&lt;-</span> get</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    put (f a b)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  get</span></code></pre></div>
<h3 id="foldl-and-for_-restricted-to-state-are-equivalent"><code>foldl</code> and <code>for_</code> (restricted to <code>State</code>) are equivalent</h3>
<p>And not only can we get <code>foldl</code> from <code>for_</code> (restricted to <code>State</code>),
we can get <code>for_</code> (restricted to <code>State</code>) from <code>foldl</code>. They are
equivalent! Importantly, they are equivalent in both result and
performance characteristics.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">forStateFromFoldl ::</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">forall</span> a b<span class="op">.</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">forall</span> a b<span class="op">.</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  [b] <span class="ot">-&gt;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  (b <span class="ot">-&gt;</span> <span class="dt">State</span> a ()) <span class="ot">-&gt;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">State</span> a ()</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>forStateFromFoldl <span class="fu">foldl</span> bs f <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  z <span class="ot">&lt;-</span> get</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>  put (<span class="fu">foldl</span> g z bs)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    g a b <span class="ot">=</span> execState (f b) a</span></code></pre></div>
<p>That is to say, having <code>foldl</code> is equivalent to being able to
<code>traverse_</code> in <code>State</code>. If you have a <code>foldl</code> in your program you may
as well have used <code>traverse_</code> or <code>for_</code> with <code>State</code> (or vice versa).</p>
<h3 id="strictness">Strictness</h3>
<p>The same analysis works for the strict left fold, <code>foldl'</code>, in place
of lazy left fold, <code>foldl</code>. To obtain <code>foldl'</code> from <code>for_</code> we would
have to change <code>foldlFromForState</code> to use <code>put $! f a b</code> in place of
<code>put (f a b)</code>. <code>forStateFromFoldl'</code> would be a version of <code>for_</code>
(restricted to <code>State</code>) that forces its state after every iteration.</p>
<h2 id="foldr-traverses-with-anything"><code>foldr</code> traverses with anything</h2>
<p>How does the behaviour of <code>foldr</code> differ? Suppose we didn’t have
<code>foldr</code>, we only had <code>for_</code> (the general version). Nonetheless, we
could recover <code>foldr</code>. The example below shows how; it converts an
<code>Applicative</code>-polymorphic <code>for_</code> into <code>foldr</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foldrFromFor ::</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">forall</span> b f<span class="op">.</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> [b] <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> f ()) <span class="ot">-&gt;</span> f ()) <span class="ot">-&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">forall</span> a b<span class="op">.</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">-&gt;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>  [b] <span class="ot">-&gt;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  a</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>foldrFromFor for_ f z bs <span class="ot">=</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>  runEndoApplicative z <span class="op">$</span> for_ bs <span class="op">$</span> \b <span class="ot">-&gt;</span> mkEndoApplicative (f b)</span></code></pre></div>
<p>I’ve used the following convenient type definition and functions:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">EndoApplicative</span> a <span class="ot">=</span> <span class="dt">Const</span> (<span class="dt">Endo</span> a)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="ot">mkEndoApplicative ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">EndoApplicative</span> a ()</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>mkEndoApplicative <span class="ot">=</span> <span class="dt">Const</span> <span class="op">.</span> <span class="dt">Endo</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="ot">runEndoApplicative ::</span> a <span class="ot">-&gt;</span> <span class="dt">EndoApplicative</span> a () <span class="ot">-&gt;</span> a</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>runEndoApplicative a (<span class="dt">Const</span> (<span class="dt">Endo</span> f)) <span class="ot">=</span> f a</span></code></pre></div>
<h3 id="foldr-and-for_-the-general-version-are-equivalent"><code>foldr</code> and <code>for_</code> (the general version) are equivalent</h3>
<p>And not only can we get <code>foldr</code> from <code>for_</code>, we can get <code>for_</code> from
<code>foldr</code>. They are equivalent. Again, the equivalence is one not only
of result but also of performance characteristics.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">forFromFoldr ::</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">forall</span> a b<span class="op">.</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">forall</span> b f<span class="op">.</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Applicative</span> f <span class="ot">=&gt;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  [b] <span class="ot">-&gt;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  (b <span class="ot">-&gt;</span> f ()) <span class="ot">-&gt;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  f ()</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>forFromFoldr <span class="fu">foldr</span> bs f <span class="ot">=</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">foldr</span> (\b rest <span class="ot">-&gt;</span> f b <span class="op">*&gt;</span> rest) (<span class="fu">pure</span> ()) bs</span></code></pre></div>
<p>That is to say, having <code>foldr</code> is equivalent to being able to
<code>traverse_</code>. If you have a <code>foldr</code> in your program you may as well
just have used <code>traverse_</code> or <code>for_</code> with an appropriate choice of
<code>Applicative</code> (or vice versa).</p>
<h2 id="example-of-the-difference">Example of the difference</h2>
<p>What can we do with this new knowledge? Let’s look at the example of
printing all even elements of a list. We can do so using <code>foldr</code> but
the equivalent in terms of <code>for_</code> (choosing the <code>Applicative</code> to be
<code>IO</code>) is clearer. The “equivalent” in terms of <code>foldl</code> is wrong; it
uses <em>O(n)</em> space (and completely fails on infinite lists).</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">printEvensFoldr ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>printEvensFoldr <span class="ot">=</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">foldr</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    (\i rest <span class="ot">-&gt;</span> when (<span class="fu">even</span> i) (<span class="fu">print</span> i) <span class="op">*&gt;</span> rest)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    (<span class="fu">pure</span> ())</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="ot">printEvensFor ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>printEvensFor is <span class="ot">=</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>  for_ is <span class="op">$</span> \i <span class="ot">-&gt;</span> when (<span class="fu">even</span> i) (<span class="fu">print</span> i)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="ot">printEvensFoldl ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>printEvensFoldl <span class="ot">=</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">foldl</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    (\rest i <span class="ot">-&gt;</span> when (<span class="fu">even</span> i) (<span class="fu">print</span> i) <span class="op">*&gt;</span> rest)</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    (<span class="fu">pure</span> ())</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span> <span class="fu">reverse</span></span></code></pre></div>
<h2 id="solving-an-old-riddle">Solving an old riddle</h2>
<p>An <a href="https://wiki.haskell.org/Foldl_as_foldr">old riddle</a> challenges us
to write <code>foldl</code> in terms of <code>foldr</code>. Personally I find the riddle
impossible to solve directly and even when I know the answer I can
hardly understand it. With the code above, though, we can solve the
riddle with no further thought. We know how to turn <code>foldr</code> into
<code>for_</code> and <code>for_</code> into <code>foldl</code>, so we simply compose.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foldlFromFoldr ::</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">forall</span> a b<span class="op">.</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">forall</span> a b<span class="op">.</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">-&gt;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  [b] <span class="ot">-&gt;</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  a</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>foldlFromFoldr <span class="fu">foldr</span> <span class="ot">=</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>  foldlFromForState (forFromFoldr <span class="fu">foldr</span>)</span></code></pre></div>
<p>After purely mechanical simplification (see appendix below) this
becomes</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span> (\b rest a <span class="ot">-&gt;</span> rest (f a b)) <span class="fu">id</span> bs z</span></code></pre></div>
<p>We didn’t need to use any brainpower to solve the riddle! The riddle
can also be solved for <code>foldl'</code>. It ends up the same except with a
strict application:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span> (\b rest a <span class="ot">-&gt;</span> rest <span class="op">$!</span> f a b) <span class="fu">id</span> bs z</span></code></pre></div>
<h2 id="should-i-use-foldl-foldl-or-foldr">Should I use <code>foldl'</code>, <code>foldl</code> or <code>foldr</code>?</h2>
<p>Now we’re ready to resolve the original dilemma. We’ve seen that the
only difference in functionality between <code>foldl</code> and <code>foldr</code> is that
the latter can be used in a wider range of situations. In consequence
we can specify when one should be used in preference to another.</p>
<h3 id="never-use-foldl">Never use <code>foldl</code></h3>
<p>Firstly, regarding the choice between the two left folds, always use
the strict version <code>foldl'</code>, not the lazy version <code>foldl</code>. The latter
can cause space leaks when strictness analysis is off; the former
always avoids those space leaks. I’ve never seen a reason to use
<code>foldl</code>.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> This advice is common knowledge in the Haskell community
and not directly the subject of this article but it seems appropriate
to reiterate it.</p>
<h3 id="use-foldl-in-preference-to-foldr">Use <code>foldl'</code> in preference to <code>foldr</code></h3>
<p>Regarding the choice between left and right fold, our first thought
might have been been to take into account the ostensible distinction
that the former “associates to the left” and the latter “to the
right”. But we are no longer distracted by this mirage. We saw above
that <code>foldl'</code> is equivalent to <code>for_</code> restricted to (a strict use of)
<code>State</code>, and <code>foldr</code> is equivalent to general <code>for_</code>, so <code>foldl'</code> is a
special case of <code>foldr</code>. According to the <a href="https://wiki.c2.com/?PrincipleOfLeastPower">Principle of Least
Power</a> you should use
<code>foldl'</code> in preference to <code>foldr</code> when you can, this is, when the
operation you want to perform is to traverse the list with a state
parameter.</p>
<h3 id="maybe-just-use-for_">Maybe just use <code>for_</code></h3>
<p><code>foldr</code> does not do a <em>different</em> job to <code>foldl'</code>: it does a more
general version of the <em>same</em> job. This was not immediately clear,
however; it required careful analysis. The lack of clarity around the
behavior of folds might be an argument for avoiding them and instead
using <code>for_</code> with an appropriate choice of <code>Applicative</code>. Personally,
I find <code>for_</code> much clearer than <code>foldr</code> in many cases. The <code>base</code>
<a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/src/GHC.List.html#%21%3F">implementation</a>
of <code>(!?)</code>, below, is a case in point. It is a <code>foldr</code> that simulates
a <code>for_</code> in a composition of <code>StateT</code> and <code>Either</code> by handwriting the
bind (<code>(&gt;&gt;=)</code>).</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(!?) ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>xs <span class="op">!?</span> n</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> n <span class="op">&lt;</span> <span class="dv">0</span>     <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">foldr</span> (\x r k <span class="ot">-&gt;</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> k <span class="kw">of</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> x</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>        _ <span class="ot">-&gt;</span> r (k<span class="op">-</span><span class="dv">1</span>)) (<span class="fu">const</span> <span class="dt">Nothing</span>) xs n</span></code></pre></div>
<p>I find it much clearer written as a literal <code>for_</code>, as below (but it
can’t be, because <code>StateT</code> isn’t in <code>base</code>). The two implementations
should have equal performance when compiled, assuming sufficient
inlining, because <code>for_</code> for lists in <code>base</code> is implemented in terms
of <code>foldr</code>.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>xs <span class="op">!?</span> n <span class="ot">=</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> n <span class="op">&lt;</span> <span class="dv">0</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>      fromEither <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        <span class="fu">flip</span> evalStateT n <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>          for_ xs <span class="op">$</span> \x <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>            get <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>              <span class="dv">0</span> <span class="ot">-&gt;</span> lift (<span class="dt">Left</span> (<span class="dt">Just</span> x))</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>              k <span class="ot">-&gt;</span> put (k <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Left</span> <span class="dt">Nothing</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="ot">fromEither ::</span> <span class="dt">Either</span> a a <span class="ot">-&gt;</span> a</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>fromEither <span class="ot">=</span> <span class="fu">either</span> <span class="fu">id</span> <span class="fu">id</span></span></code></pre></div>
<h3 id="isnt-for_-imperative">Isn’t <code>for_</code> imperative?</h3>
<p>Yes. Although I don’t know how to precisely define “imperative style”
I am confident in saying that the style of <code>(!?)</code> defined with <code>foldr</code>
is functional and the style of <code>(!?)</code> defined with <code>for_</code> is
imperative. Yet they calculate exactly the same thing in exactly the
same way. In fact, I think the implementation with <code>for_</code> is both
imperative and clearer. How can that be? Don’t functional
programmers eschew imperative style? Actually, no: I also think that
Haskell is the world’s finest imperative programming language!</p>
<p>What does the algorithm look like in other imperative programming
languages? Below are two implementations in Python. Each shows the
weakness of Python’s support for imperative programming compared to
Haskell. In the first example the scopes of <code>k</code>, <code>ret</code> and <code>x</code> are
limited to no less than the rest of the function, and the <code>break</code> is
implicitly scoped to the closest enclosing <code>for</code> – you don’t get a
choice about that. By contrast, the corresponding Haskell variables
are scoped to their precise range of use, and the <code>break</code> equivalent
is scoped precisely to its enclosing handler, <code>fromEither</code>. The scope
is maintained even across function call boundaries so you can refactor
and abstract. The second Python example is no better; it just trades
a too-large scope of <code>ret</code> for an abstraction-resistant scope of early
<code>return</code>.</p>
<p>I find imperative style programming in Haskell clear to understand and
easy to reason about exactly because Haskell’s type system and
expression-based nature allows fine-grained effect tracking and
precise control of the scopes of values and effects.</p>
<p>Python example avoiding early return:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode .py"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lookup(xs, n):</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> n <span class="op">&lt;</span> <span class="dv">0</span>: <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  k <span class="op">=</span> n</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  ret <span class="op">=</span> <span class="va">None</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> x <span class="kw">in</span> xs:</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> k <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>      ret <span class="op">=</span> x</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>      <span class="cf">break</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    k <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ret</span></code></pre></div>
<p>Python example with early return:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode .py"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lookup(xs, n):</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> n <span class="op">&lt;</span> <span class="dv">0</span>: <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  k <span class="op">=</span> n</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> x <span class="kw">in</span> xs:</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> k <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> x</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    k <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="va">None</span></span></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>By carefully analysing the behaviour of three Haskell folds on lists
we were able to determine when we should use each. We even discovered
that “imperative style” programming in Haskell can be clearer than
“functional style”. In summary, never use <code>foldl</code>, prefer <code>foldl'</code> to
<code>foldr</code> where you can, or maybe just forget them all and use <code>for_</code>
instead.</p>
<h2 id="references-and-commentary">References and commentary</h2>
<h3 id="monoids"><code>Monoid</code>s</h3>
<p>This article is the culmination of an idea I wrote about years ago:
<em><a href="http://web.jaguarpaw.co.uk/~tom/blog/posts/2012-11-04-what-is-foldr-made-of.html">What is <code>foldr</code> made
of?</a></em>.
Brent Yorgey wrote a follow-up, <em><a href="https://byorgey.wordpress.com/2012/11/05/foldr-is-made-of-monoids/"><code>foldr</code> is made of
monoids</a></em>.
One lesson of the present article is that <code>foldr</code> being “made of
monoids” is equivalent to it being “made of applicatives whose result
type we ignore”, because when you have an applicative whose result
type you ignore, that’s equivalent to having a monoid.</p>
<p>There is also a <em>specific</em> <code>Applicative</code> that corresponds directly to
any given <code>Monoid</code> <code>m</code>, that is, <code>Const m</code>, and my earlier blog post
showed that there is a specific <code>Moniod</code> that <code>foldr</code> is “made of”:
<code>Endo a</code>; that’s why we ended up using <code>Const</code> and <code>Endo</code> to define
<code>foldrFromFor</code>. Instead of “<code>foldr</code> traverses with anything” we could
have said “<code>foldr</code> traverses with <code>Const (Endo _)</code>” (but that’s much
less catchy). However, it is worth observing that the following
characterizations are also valid:</p>
<ul>
<li>“<code>foldl</code> <code>foldMap</code>s with <code>Dual (Endo _)</code>”</li>
<li>“<code>foldr</code> <code>foldMap</code>s with any <code>Monoid</code>”</li>
<li>“<code>foldl'</code> <code>foldMap</code>s with <code>StrictEndo _</code>”</li>
<li>“<code>foldr</code> <code>foldMap</code>s with <code>Endo _</code>”</li>
</ul>
<p>(where <code>StrictEndo</code> is <a href="https://discourse.haskell.org/t/is-there-a-strict-endo/8441">a strict version of <code>Endo</code>, which doesn’t seem
to exist anywhere in the Haskell
ecosystem</a>).
The lens library takes advantage of these correspondences in its
definitions of
<a href="https://www.stackage.org/haddock/lts-22.4/lens-5.2.3/Control-Lens-Fold.html#v:foldlOf%27"><code>foldlOf'</code></a>,
<a href="https://www.stackage.org/haddock/lts-22.4/lens-5.2.3/Control-Lens-Fold.html#v:foldlOf"><code>foldlOf</code></a>
and
<a href="https://www.stackage.org/haddock/lts-22.4/lens-5.2.3/Control-Lens-Fold.html#v:foldrOf"><code>foldrOf</code></a>
(although it uses <code>Endo (Endo _)</code> instead of <code>StrictEndo _</code>).</p>
<p>In any case, the slogan “<code>foldl</code> traverses with <code>State</code>, <code>foldr</code>
traverses with anything” seems the most catchy and the easiest to use
as a guide to practice.</p>
<h3 id="other-references">Other references</h3>
<p>Alexis King has <a href="https://github.com/hasura/graphql-engine/pull/2933#discussion_r328821960">a post from 2019 explaining the difference between
<code>foldl</code> and
<code>foldr</code></a>.
She agrees that one should never use <code>foldl</code>. Regarding the
distinction between <code>foldl'</code> and <code>foldr</code> she writes</p>
<blockquote>
<p>When the accumulation function is strict, use foldl’ to consume the
list in constant space, since the whole list is going to have to be
traversed, anyway. When the accumulation function is lazy in its
second argument, use foldr.</p>
</blockquote>
<p>Those rules of thumb are hard to apply because they presuppose that
you already have an (“accumulation”) function (which is also a
misnomer: in the case of foldr it doesn’t accumulate). That is, it’s a
rule that you can use if you start with a function, to determine which
fold to use with that function. By contrast, this article presents a
rule that you can use if you start with a problem, to determine which
fold can solve your problem. If your problem is “traverse with (only)
a state”-shaped then the answer is <code>foldl'</code>; if the problem is
“traverse with anything else”-shaped then the answer is <code>foldr</code>(or in
either case you could just use <code>for_</code>).</p>
<p>Yao Li et al. address the choice of folds in <a href="https://dl.acm.org/doi/pdf/10.1145/3473585">Reasoning about the
Garden of Forking Paths</a>
from the point of view of laziness and demand analysis.</p>
<h3 id="foldm"><code>foldM</code></h3>
<p>There is corresponding characterization of <code>foldM</code>: “<code>foldM</code> traverses
with <code>StateT</code>”, as demonstrated by the following, which is a minor
adjustment to the <code>foldl</code> equivalents.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foldMFromForStateT ::</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  ( <span class="kw">forall</span> a b m<span class="op">.</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Monad</span> m <span class="ot">=&gt;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    [b] <span class="ot">-&gt;</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    (b <span class="ot">-&gt;</span> <span class="dt">StateT</span> a m ()) <span class="ot">-&gt;</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">StateT</span> a m ()</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>  ) <span class="ot">-&gt;</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">forall</span> a b m<span class="op">.</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Monad</span> m <span class="ot">=&gt;</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>  (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">-&gt;</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>  [b] <span class="ot">-&gt;</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>  m a</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>foldMFromForStateT for_ f z bs <span class="ot">=</span> <span class="fu">flip</span> evalStateT z <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>  for_ bs <span class="op">$</span> \b <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    a <span class="ot">&lt;-</span> get</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    put <span class="op">=&lt;&lt;</span> lift (f a b)</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>  get</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a><span class="ot">forStateTFromFoldM ::</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>  ( <span class="kw">forall</span> a b m<span class="op">.</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Monad</span> m <span class="ot">=&gt;</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>    (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>    a <span class="ot">-&gt;</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>    [b] <span class="ot">-&gt;</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>    m a</span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a>  ) <span class="ot">-&gt;</span></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">forall</span> a b m<span class="op">.</span></span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Monad</span> m <span class="ot">=&gt;</span></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>  [b] <span class="ot">-&gt;</span></span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>  (b <span class="ot">-&gt;</span> <span class="dt">StateT</span> a m ()) <span class="ot">-&gt;</span></span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a>  <span class="dt">StateT</span> a m ()</span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a>forStateTFromFoldM foldM bs f <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a>  z <span class="ot">&lt;-</span> get</span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a>  put <span class="op">=&lt;&lt;</span> lift (foldM g z bs)</span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a>    g a b <span class="ot">=</span> execStateT (f b) a</span></code></pre></div>
<h3 id="why-is-written-that-way">Why is <code>(!?)</code> written that way?</h3>
<p>It would be even clearer to write <code>(!?)</code> as below. Why not just do
that instead, instead of considering <code>foldr</code> and <code>for_</code>? Because when
written in terms of <code>foldr</code> GHC can apply <a href="https://wiki.haskell.org/Correctness_of_short_cut_fusion#Short_cut_fusion">short cut
fusion</a>,
a rewrite rule that leads to an optimization.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span> <span class="op">!?</span> (x<span class="op">:</span>_) <span class="ot">=</span> <span class="dt">Just</span> x</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>_ <span class="op">!?</span> [] <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>n <span class="op">!?</span> (_<span class="op">:</span>xs) <span class="ot">=</span> (n<span class="op">-</span><span class="dv">1</span>) <span class="op">!?</span> xs</span></code></pre></div>
<p>Thanks to <a href="https://discourse.haskell.org/t/foldl-traverses-with-state-foldr-traverses-with-anything/8491/17">tobz619 for raising this
question</a>
and suggesting the alternative implementation.</p>
<h3 id="its-always-traverse">“It’s always <code>traverse</code>”</h3>
<p>There’s a running joke in the Haskell world that “it’s always
<code>traverse</code>”, that is, many complicated transformations can be boiled
down to a use of <code>traverse</code>. This article sheds more light on that
phenomenon; <code>foldl</code>, <code>foldl'</code>, <code>foldr</code> and <code>foldM</code> are just different
flavours of <code>traverse_</code>.</p>
<h3 id="foldable"><code>Foldable</code></h3>
<p>This article only discusses the relationship between <code>foldl</code> and
<code>foldr</code> as functions on lists, not as functions in the <code>Foldable</code>
class; that can of worms deserves an article of its own. However, the
slogan “<code>foldl</code> traverses with <code>State</code>, <code>foldr</code> traverses with
anything” can be seen as specifying a putative <em>law</em> for how the
<code>Foldable</code> versions of these functions should behave. Determining
whether that law holds in practice, and role of the mysterious
<code>foldr'</code>, requires further analysis.</p>
<h2 id="appendix-calculations-for-solving-the-riddle">Appendix: Calculations for solving the riddle</h2>
<p>He we do the calculation for <code>foldl</code>. The calculation for <code>foldl'</code> is
almost identical. Starting from the original definition of
<code>foldlFromFoldr</code>, after inlining <code>foldlFromForState</code> and
<code>forFromFoldr</code>, we get</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foldlFromFoldr ::</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">forall</span> a b<span class="op">.</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">forall</span> a b<span class="op">.</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">-&gt;</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  [b] <span class="ot">-&gt;</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  a</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>foldlFromFoldr <span class="fu">foldr</span> f' z bs' <span class="ot">=</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">flip</span> evalState z <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    for_ bs' <span class="op">$</span> \b <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>      a <span class="ot">&lt;-</span> get</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>      put (f' a b)</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>    get</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>    for_ bs f <span class="ot">=</span> <span class="fu">foldr</span> (\b rest <span class="ot">-&gt;</span> f b <span class="op">*&gt;</span> rest) (<span class="fu">pure</span> ()) bs</span></code></pre></div>
<p>Then we can extract the body of <code>for_</code> as a variable <code>g</code></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">flip</span> evalState z <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  for_ bs' g</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  get</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="kw">where</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  for_ bs f <span class="ot">=</span> <span class="fu">foldr</span> (\b rest <span class="ot">-&gt;</span> f b <span class="op">*&gt;</span> rest) (<span class="fu">pure</span> ()) bs</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>  g b <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    a <span class="ot">&lt;-</span> get</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    put (f' a b)</span></code></pre></div>
<p>Then inline <code>for_</code></p>
<div class="sourceCode" id="cb21"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">flip</span> evalState z <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">foldr</span> (\b rest <span class="ot">-&gt;</span> g b <span class="op">*&gt;</span> rest) (<span class="fu">pure</span> ()) bs</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  get</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="kw">where</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>  g b <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    a <span class="ot">&lt;-</span> get</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    put (f a b)</span></code></pre></div>
<p>Write <code>g</code> in terms of <code>modify</code></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">flip</span> evalState z <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">foldr</span> (\b rest <span class="ot">-&gt;</span> g b <span class="op">*&gt;</span> rest) (<span class="fu">pure</span> ()) bs</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  get</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="kw">where</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>  g b <span class="ot">=</span> modify (<span class="fu">flip</span> f b)</span></code></pre></div>
<p>and then inline <code>g</code></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="fu">flip</span> evalState z <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">foldr</span> (\b rest <span class="ot">-&gt;</span> modify (<span class="fu">flip</span> f b) <span class="op">*&gt;</span> rest) (<span class="fu">pure</span> ()) bs</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>  get</span></code></pre></div>
<p>and use <code>execState</code> rather than <code>evalState</code> with <code>get</code></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">flip</span> execState z <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">foldr</span> (\b rest <span class="ot">-&gt;</span> modify (<span class="fu">flip</span> f b) <span class="op">*&gt;</span> rest) (<span class="fu">pure</span> ()) bs</span></code></pre></div>
<p>Now we can take advantage of an interesting property of <code>foldr</code>, that
when <code>h . g == id</code> we have the equality</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span> (\a <span class="ot">-&gt;</span> f a) z <span class="op">==</span> h <span class="op">.</span> <span class="fu">foldr</span> (\a <span class="ot">-&gt;</span> g <span class="op">.</span> f a <span class="op">.</span> h) (g z)</span></code></pre></div>
<p>(I don’t know if this is a free theorem or whether you have to prove
it by induction.) Observing that <code>execState</code> and <code>modify</code> are
inverses we get</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">flip</span> execState z <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>  modify <span class="op">$</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">foldr</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>      (\b rest <span class="ot">-&gt;</span> execState <span class="op">$</span> modify (<span class="fu">flip</span> f b) <span class="op">*&gt;</span> modify rest)</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>      (execState (<span class="fu">pure</span> ()))</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>      bs</span></code></pre></div>
<p>We can combine the two <code>modify</code>s to get</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">flip</span> execState z <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  modify <span class="op">$</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">foldr</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>      (\b rest <span class="ot">-&gt;</span> execState <span class="op">$</span> modify (rest <span class="op">.</span> <span class="fu">flip</span> f b))</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>      (execState (<span class="fu">pure</span> ()))</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>      bs</span></code></pre></div>
<p>and use that <code>execState . modify == id</code> to get</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>  (\b rest <span class="ot">-&gt;</span> rest <span class="op">.</span> <span class="fu">flip</span> f b)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>  (execState (<span class="fu">pure</span> ()))</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>  bs</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>  z</span></code></pre></div>
<p>which is</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span> (\b rest a <span class="ot">-&gt;</span> rest (f a b)) <span class="fu">id</span> bs z</span></code></pre></div>
<p>The same calculation for <code>foldl'</code> yields</p>
<pre><code>foldr (\b rest a -&gt; rest $! f a b) id bs z</code></pre>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>assuming strictness analysis is on, otherwise it has space leak
– <code>foldl'</code> always calculates it in constant space<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>If you’ve miraculously discovered a case where <code>foldl</code> is better
then please <a href="http://web.jaguarpaw.co.uk/~tom/contact">tell me</a>
because I would be astonished to learn about it.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</div>
<hr>

  </div>

<!-- End Document
================================================== -->
</body>
</html>
