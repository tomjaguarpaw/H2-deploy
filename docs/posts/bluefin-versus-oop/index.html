<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html lang="en"> <!--<![endif]-->
<head>

        <!-- Basic Page Needs
================================================== -->
        <meta charset="utf-8">
  <title>bluefin-versus-oop</title>
        <meta name="description" content>
        <meta name="author" content>

        <!-- Fonts
================================================== -->
  <link href="http://fonts.googleapis.com/css?family=PT+Sans" rel="stylesheet" type="text/css">
  <link href="http://fonts.googleapis.com/css?family=PT+Serif" rel="stylesheet" type="text/css">

        <!-- Mobile Specific Metas
================================================== -->
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- CSS
================================================== -->
  <link rel="stylesheet" href="../../css/combined.css">

  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>

        <!--[if lt IE 9]>
                <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->

        <!-- Atom
        ================================================== -->
</head>
<body>

        <!-- Primary Page Layout
        ================================================== -->
  <div class="container">
  <div class="ten columns offset-by-three">
  <h1 style="margin-top: 40px"><a class="homelink" href="../../">The H2 Wiki</a></h1>
  <hr />
</div>
<div class="twelve columns offset-by-two">
  <h3>bluefin-versus-oop</h3>
  <h1 id="bluefin-versus-oop">Bluefin versus OOP</h1>
<p>– Tom Ellis, February 2025</p>
<p>In “<a href="https://osa1.net/posts/2024-10-09-oop-good.html">OOP is not that bad,
actually</a>”, Ömer
Sinan Ağacan describes a task that he says “mainstream
statically-typed OOP languages do well”. He defines OOP [object
oriented programming] as statically-typed programming with classes,
inheritance, subtyping and virtual calls.</p>
<p>Ultimately I interpret the article not as advocating for OOP, but
rather as advocating for programming against well-defined interfaces
that can be instantiated with a variety of implementations. I’m
strongly in support. However, I think the task is better solved by
Haskell, a statically-typed functional language, than by an OOP
language (as Ömer defines it). In particular, I don’t see inheritance
and subtyping as particularly valuable for this task.</p>
<p>Let’s look at Ömer’s example in more detail, in a Haskell context.</p>
<h2 id="a-logger">A logger</h2>
<p>We start with a basic logger interface. In Haskell an interface is a
type, here <code>Logger</code>. This is like the <code>Logger</code> type that Ömer
defined, except using the
<a href="https://hackage.haskell.org/package/bluefin-0.0.9.0/docs/Bluefin-Eff.html#t:Eff"><code>Eff</code></a>
type from my effect system Bluefin instead of <code>IO</code>. (Most of what I
say in this article will apply equally well to <code>IO</code> or <code>Eff</code> and I’ll
explain at the end why I think <code>Eff</code> is better.)</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Severity</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Logger</span> e <span class="ot">=</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Log a message with a severity</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">MkLogger</span> {<span class="ot">logImpl ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Severity</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> e ()}</span></code></pre></div>
<p>Then we need a bit of ceremony to define a <code>Handle</code> instance and the
<code>log</code> function that we define in terms of the <code>Handle</code> implementation.
(This is in principle derivable using Template Haskell or Generics but
I haven’t implemented that in Bluefin yet. Mea culpa. I’m including
this boilerplate in the article to be honest and explicit.)</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Handle</span> <span class="dt">Logger</span> <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  mapHandle logger <span class="ot">=</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">MkLogger</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>      { logImpl <span class="ot">=</span> (<span class="fu">fmap</span> <span class="op">.</span> <span class="fu">fmap</span>) useImpl (logImpl logger)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="fu">log</span><span class="ot"> ::</span> (e <span class="op">:&gt;</span> es) <span class="ot">=&gt;</span> <span class="dt">Logger</span> e <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Severity</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> es ()</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="fu">log</span> <span class="ot">=</span> operationFrom logImpl</span></code></pre></div>
<p>Then immediately we can define a function, <code>exampleWithLogger</code>, which
uses the <code>Logger</code> interface. It prints some messages to stdout (using
<code>putStrLn</code>) and logs some messages to the <code>Logger</code> (using <code>log</code>).</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">exampleWithLogger ::</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  (e1 <span class="op">:&gt;</span> es, e2 <span class="op">:&gt;</span> es) <span class="ot">=&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">IOE</span> e1 <span class="ot">-&gt;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Logger</span> e2 <span class="ot">-&gt;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Eff</span> es ()</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>exampleWithLogger io logger <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  effIO io (<span class="fu">putStrLn</span> <span class="st">&quot;Started Logger example&quot;</span>)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">log</span> logger <span class="st">&quot;Mild Logger message&quot;</span> <span class="dv">0</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">log</span> logger <span class="st">&quot;Severe Logger message&quot;</span> <span class="dv">10</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  effIO io (<span class="fu">putStrLn</span> <span class="st">&quot;Ended Logger example&quot;</span>)</span></code></pre></div>
<p>Having such a function is not useful until we have a way to
instantiate the <code>Logger</code> interface. Here’s one: it prints log
messages to stdout.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">withStdoutLogger ::</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  (e1 <span class="op">:&gt;</span> es) <span class="ot">=&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">IOE</span> e1 <span class="ot">-&gt;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">forall</span> e<span class="op">.</span> <span class="dt">Logger</span> e <span class="ot">-&gt;</span> <span class="dt">Eff</span> (e <span class="op">:&amp;</span> es) r) <span class="ot">-&gt;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Eff</span> es r</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>withStdoutLogger io k <span class="ot">=</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  useImplIn</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    k</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">MkLogger</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>      { logImpl <span class="ot">=</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>          \msg sev <span class="ot">-&gt;</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>            <span class="co">-- Print log message to stdout</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>            effIO io (<span class="fu">putStrLn</span> (mkMsg msg sev))</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    mkMsg msg sev <span class="ot">=</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;Logger message: &quot;</span> <span class="op">++</span> <span class="fu">show</span> sev <span class="op">++</span> <span class="st">&quot;: &quot;</span> <span class="op">++</span> msg</span></code></pre></div>
<p>(<a href="https://hackage.haskell.org/package/bluefin-0.0.14.1/docs/Bluefin-Compound.html#v:useImplIn"><code>useImplIn</code></a>
and <a href="https://hackage.haskell.org/package/bluefin-0.0.14.1/docs/Bluefin-IO.html#v:effIO"><code>effIO io</code></a>
are Bluefin incantations. The same code using <code>IO</code> instead of <code>Eff</code>
wouldn’t have them.) I can instantiate the <code>Logger</code> interface and use
it to run the example, like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runExampleWithLogger ::</span> <span class="dt">IO</span> ()</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>runExampleWithLogger <span class="ot">=</span> runEff <span class="op">$</span> \io <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- &quot;Instantiate&quot; the Logger interface</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- with a stdout logger</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  withStdoutLogger io <span class="op">$</span> \logger <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Use the Logger &quot;instance&quot;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    exampleWithLogger io logger</span></code></pre></div>
<p>and the result is as expected:</p>
<pre><code>Started Logger example
Log msg: 0: Mild Logger message
Log msg: 10: Severe Logger message
Ended Logger example</code></pre>
<h2 id="a-minimum-severity-logger">A minimum severity logger</h2>
<p>Another example that Ömer uses is a logger which only logs above a
certain severity. Bluefin can do that too! Ömer suggested that the
minimum severity logger should be created afresh, but I actually think
it’s better to take an <em>existing</em> logger and wrap it into a minimum
severity logger. That sounds more useful, more object-oriented, and
in any case more interesting, so let’s do it:
<code>withLogAboveSeverityLogger</code> creates a logger that logs to an existing
<code>Logger</code> (passed in as an argument), but only when the severity is
above some minimum severity.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">withLogAboveSeverityLogger ::</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  (e1 <span class="op">:&gt;</span> es) <span class="ot">=&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Severity</span> <span class="ot">-&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Logger</span> e1 <span class="ot">-&gt;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">forall</span> e<span class="op">.</span> <span class="dt">Logger</span> e <span class="ot">-&gt;</span> <span class="dt">Eff</span> (e <span class="op">:&amp;</span> es) r) <span class="ot">-&gt;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Eff</span> es r</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>withLogAboveSeverityLogger minSev logger k <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  useImplIn</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    k</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">MkLogger</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>      { logImpl <span class="ot">=</span> \msg sev <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>          when (sev <span class="op">&gt;=</span> minSev) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>            <span class="fu">log</span> logger msg sev</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>      }</span></code></pre></div>
<p>Then we can make a stdout logger and restrict it so it only logs
messages of severity 5 and above:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runExampleWithLogAboveSeverityLogger ::</span> <span class="dt">IO</span> ()</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>runExampleWithLogAboveSeverityLogger <span class="ot">=</span> runEff <span class="op">$</span> \io <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Make the stdout logger</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  withStdoutLogger io <span class="op">$</span> \logger <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Only log messages of severity 5 and above</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    withLogAboveSeverityLogger <span class="dv">5</span> logger <span class="op">$</span> \severeLogger <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- Run the example with the restricted logger</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>      exampleWithLogger io severeLogger</span></code></pre></div>
<p>The output is the same except the mild (severity 0) log message is
suppressed.</p>
<pre><code>Started Logger example
Log msg: 10: Severe Logger message
Ended Logger example</code></pre>
<h2 id="a-file-logger">A file logger</h2>
<p>Finally, Ömer defines a file logger. Following the recipe seen above,
we first define an interface for this type of logger. It contains a
<code>Logger</code> whose log operation will write to a file, and an effectful
operation which flushes writes to the open file.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">FileLogger</span> e <span class="ot">=</span> <span class="dt">MkFileLogger</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> fileLoggerLogger ::</span> <span class="dt">Logger</span> e,</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    flushImpl ::</span> <span class="dt">Eff</span> e ()</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>This is “<a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">composition, not
inheritance</a>”,
a famous design principle of OOP! Again we have some ceremony.
Sorry.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Handle</span> <span class="dt">FileLogger</span> <span class="kw">where</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  mapHandle fileLogger <span class="ot">=</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">MkFileLogger</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>      { fileLoggerLogger <span class="ot">=</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>          mapHandle (fileLoggerLogger fileLogger),</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        flushImpl <span class="ot">=</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>          useImpl (flushImpl fileLogger)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="ot">flush ::</span> (e <span class="op">:&gt;</span> es) <span class="ot">=&gt;</span> <span class="dt">FileLogger</span> e <span class="ot">-&gt;</span> <span class="dt">Eff</span> es ()</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>flush <span class="ot">=</span> operationFrom flushImpl</span></code></pre></div>
<p>To create a <code>FileLogger</code> we take a file name, get access to a
writeable file handle using a Bluefin <code>withFile</code> block, and use the
file handle to define the <code>Logger</code> and the flush operation. Bluefin’s
<code>withFile</code> is bracketed, so the file is closed automatically when
leaving <code>withFileLogger</code> (even if an exception is thrown).</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">withFileLogger ::</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  (e1 <span class="op">:&gt;</span> es) <span class="ot">=&gt;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">FilePath</span> <span class="ot">-&gt;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">IOE</span> e1 <span class="ot">-&gt;</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">forall</span> e<span class="op">.</span> <span class="dt">FileLogger</span> e <span class="ot">-&gt;</span> <span class="dt">Eff</span> (e <span class="op">:&amp;</span> es) r) <span class="ot">-&gt;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Eff</span> es r</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>withFileLogger fp io k <span class="ot">=</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Open a file for writing</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>  withFile io fp <span class="dt">WriteMode</span> <span class="op">$</span> \handle <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Create the FileLogger</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    useImplIn</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>      k</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>      <span class="dt">MkFileLogger</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        { fileLoggerLogger <span class="ot">=</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>            <span class="dt">MkLogger</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>              { logImpl <span class="ot">=</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>                  \msg sev <span class="ot">-&gt;</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>                    <span class="co">-- Log to the open file</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>                    hPutStrLn handle (mkMsg msg sev)</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>              },</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>          flushImpl <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>            <span class="co">-- Diagnostic message for the sake of</span></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>            <span class="co">-- the example</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>            effIO io (<span class="fu">putStrLn</span> <span class="st">&quot;Flushing FileLogger&quot;</span>)</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>            <span class="co">-- Flush writes to the file</span></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>            hFlush handle</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a>    mkMsg msg sev <span class="ot">=</span></span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;FileLogger message: &quot;</span> <span class="op">++</span> <span class="fu">show</span> sev <span class="op">++</span> <span class="st">&quot;: &quot;</span> <span class="op">++</span> msg</span></code></pre></div>
<p>We want to be able to use functions that accept <code>Logger</code> with our
<code>FileLogger</code>. But how can we? Haskell doesn’t have subtyping!
That’s OK: Haskell has functions. We just apply the function
<code>fileLoggerLogger</code>. This achieves the same end as subtyping would,
but with an explicit use of function application rather than an
implicit use of the type system.</p>
<p>Then we can use a <code>FileLogger</code> with our function <code>exampleWithLogger</code>,
which expected a <code>Logger</code></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">exampleWithFileLogger ::</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  (e1 <span class="op">:&gt;</span> es, e2 <span class="op">:&gt;</span> es) <span class="ot">=&gt;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">IOE</span> e1 <span class="ot">-&gt;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">FileLogger</span> e2 <span class="ot">-&gt;</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Eff</span> es ()</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>exampleWithFileLogger io fileLogger <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Create a Logger from the FileLogger</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> logger <span class="ot">=</span> fileLoggerLogger fileLogger</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>  effIO io (<span class="fu">putStrLn</span> <span class="st">&quot;Started FileLogger example&quot;</span>)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Log to the FileLogger</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">log</span> logger <span class="st">&quot;Mild FileLogger message&quot;</span> <span class="dv">0</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>  withLogAboveSeverityLogger <span class="dv">5</span> logger <span class="op">$</span> \severeLogger <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    exampleWithLogger io severeLogger</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Flush the FileLogger</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>  flush fileLogger</span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>  <span class="fu">log</span> logger <span class="st">&quot;Severe FileLogger message&quot;</span> <span class="dv">10</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>  effIO io (<span class="fu">putStrLn</span> <span class="st">&quot;Ended Logger example&quot;</span>)</span></code></pre></div>
<p>and run it (using the “file” <code>/dev/stdout</code>, so that all messages
appear directly on the console for the benefit of exposition).</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runExampleWithFileLogger ::</span> <span class="dt">IO</span> ()</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>runExampleWithFileLogger <span class="ot">=</span> runEff <span class="op">$</span> \io <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Create the FileLogger</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  withFileLogger <span class="st">&quot;/dev/stdout&quot;</span> io <span class="op">$</span> \fileLogger <span class="ot">-&gt;</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Use the FileLogger</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    exampleWithFileLogger io fileLogger</span></code></pre></div>
<p>We can see that the <code>FileLogger</code> is used for all messages, it is
flushed at the expected point, and the mild (severity 0) message
arising from <code>exampleWithLogger</code> is suppressed (as it was above in
<code>runExampleWithLogAboveSeverityLogger</code>).</p>
<pre><code>Opening file
Started FileLogger example
File logger message: 0: Mild FileLogger message
Started Logger example
File logger message: 10: Severe Logger message
Ended Logger example
Flushing FileLogger
File logger message: 10: Severe FileLogger message
Ended Logger example
Closing file</code></pre>
<h2 id="so-bluefin-versus-oop">So, Bluefin versus OOP?</h2>
<p>Before getting to the stage that we have now reached, Ömer suggested
that our approach is unworkable:</p>
<blockquote>
<p>unlike our OOP example, existing code that uses the <code>Logger</code> type
and <code>log</code> function cannot work with this new [<code>FileLogger</code>]
type. There needs to be some refactoring, and how the user code will
need to be refactored depends on how we want to expose this new type
to the users.</p>
</blockquote>
<p>I don’t understand why. The approach taken in this article seems
perfectly workable to me, even very natural, and doesn’t require any
refactoring of existing code. It uses explicit function application
instead of implicit subtyping.</p>
<p>The one element that one might think OOP languages do better is
avoiding the explicit function application. But we don’t need
subtyping, even for that! All we need is a way for a value to
implicitly conform to some interface, in Haskell a type class. For
example:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">IsLogger</span> h <span class="kw">where</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  isLogger ::</span> h e <span class="ot">-&gt;</span> <span class="dt">Logger</span> e</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">IsLogger</span> <span class="dt">FileLogger</span> <span class="kw">where</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  isLogger <span class="ot">=</span> fileLoggerLogger</span></code></pre></div>
<p>And we could define functions to take an instance of <code>IsLogger</code> rather
than a concrete <code>Logger</code>, for example change</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">exampleWithLogger ::</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  (e1 <span class="op">:&gt;</span> es, e2 <span class="op">:&gt;</span> es) <span class="ot">=&gt;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">IOE</span> e1 <span class="ot">-&gt;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Logger</span> e2 <span class="ot">-&gt;</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Eff</span> es ()</span></code></pre></div>
<p>to</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">exampleWithLogger ::</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  (e1 <span class="op">:&gt;</span> es, e2 <span class="op">:&gt;</span> es, <span class="dt">IsLogger</span> logger) <span class="ot">=&gt;</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">IOE</span> e1 <span class="ot">-&gt;</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  logger e2 <span class="ot">-&gt;</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Eff</span> es ()</span></code></pre></div>
<p><em>That</em> would involve some refactoring, if we’ve already defined a
suite of functions that accept <code>Logger</code>, but it’s not required, even
if potentially convenient. I’m inclined to say that being explicit is
clearer anyway, but then I like neither the implicit subtyping
approach of OO style, nor the implicit type class approach of many
Haskell libraries, to begin with.</p>
<h2 id="bluefin-or-haskell">Bluefin or Haskell?</h2>
<p>Even if we like this style of “programming against well-defined
interfaces that can be instantiated with a variety of
implementations”, are we really getting the benefits from Bluefin, or
just Haskell? Well, a significant part comes from Haskell, but there
are a couple of notable additional benefits of Bluefin: effect
tracking and resource safety.</p>
<h3 id="effect-tracking">Effect tracking</h3>
<p>Firstly, Bluefin enforces strict controls, through the type system,
over what functions can and cannot do. For example, we can add a
logger that yields log messages to a Bluefin <code>Stream</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">streamLogger ::</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  (e1 <span class="op">:&gt;</span> es) <span class="ot">=&gt;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Stream</span> <span class="dt">String</span> e1 <span class="ot">-&gt;</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">forall</span> e<span class="op">.</span> <span class="dt">Logger</span> e <span class="ot">-&gt;</span> <span class="dt">Eff</span> (e <span class="op">:&amp;</span> es) r) <span class="ot">-&gt;</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Eff</span> es r</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>streamLogger stream k <span class="ot">=</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  useImplIn</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    k</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">MkLogger</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>      { logImpl <span class="ot">=</span> \msg sev <span class="ot">-&gt;</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>          yield stream (mkMsg msg sev)</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    mkMsg msg sev <span class="ot">=</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;streamLogger message: &quot;</span> <span class="op">++</span> <span class="fu">show</span> sev <span class="op">++</span> <span class="st">&quot;: &quot;</span> <span class="op">++</span> msg</span></code></pre></div>
<p>Later we can choose what to do with the elements from the stream.
Here we print them.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runExampleStreamLogger ::</span> <span class="dt">IO</span> ()</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>runExampleStreamLogger <span class="ot">=</span> runEff <span class="op">$</span> \io <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  forEach</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    ( \stream <span class="ot">-&gt;</span> streamLogger stream <span class="op">$</span> \logger <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>        exampleWithLogger io logger</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    ( \logMsg <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>        effIO io (<span class="fu">putStrLn</span> logMsg)</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    )</span></code></pre></div>
<p>The end product is the same as <code>runExampleWithLogger</code> above.</p>
<pre><code>Started Logger example
streamLogger message: 0: Mild Logger message
streamLogger message: 10: Severe Logger message
Ended Logger example</code></pre>
<p>But the way we have factored the program is different. From the
program structure it is clear that using <code>streamLogger</code> does not
perform any <code>IO</code> (there is no <code>IOE</code> argument to <code>streamLogger</code>) even
though other parts of the program do perform <code>IO</code>. This fine-grained
tracking of effects is not possible if you use the raw <code>IO</code> monad
(anything that runs in <code>IO</code> can perform any possible effect) nor is
such tracking possible in any “mainstream, statically-typed OOP
language”.</p>
<h3 id="resource-safety">Resource safety</h3>
<p>Secondly, the file handle supplied by
<a href="https://hackage.haskell.org/package/bluefin-0.0.14.1/docs/Bluefin-System-IO.html#v:withFile"><code>withFile</code></a>
(used in the definition of <code>withFileLogger</code>) is guaranteed not to
escape its scope, that is, it’s not possible to use it after
<code>withFileLogger</code> has returned. That guarantee is not provided by
Haskell’s standard
<a href="https://www.stackage.org/haddock/lts-22.39/base-4.18.2.1/System-IO.html#v:withFile"><code>System.IO.withFile</code></a>.</p>
<h2 id="worse">Worse?</h2>
<p>In what ways is Bluefin worse than an OOP language, or just pure Haskell?</p>
<p>Well, we’ve seen that there is ceremony and boilerplate involved in
defining and using Bluefin effects. Much of this can in principle be
addressed by generating the boilerplate using Template Haskell or
Generics, but tracking fine-grained effects at the type system is
always going to be less convenient than using plain <code>IO</code> (in Haskell),
or than using nothing (in every other language).</p>
<p>Setting up the “subtyping” relationship using <code>IsLogger</code> also requires
some boilerplate. In OO languages it comes for free, syntactically
free anyway.</p>
<p>I think these costs are worth paying, but I won’t be surprised if
others have different preferences.</p>
<h2 id="conclusion">Conclusion</h2>
<p>For my purposes, I’m happy to say that “<a href="https://osa1.net/posts/2024-10-09-oop-good.html">Bluefin is better than OOP,
actually</a>”.</p>
<h2 id="appendix">Appendix</h2>
<p>The code in this article uses the following convenience function,
which may or may not be added to Bluefin at a later date.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode .hs"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">operationFrom ::</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">Handle</span> h, e <span class="op">:&gt;</span> es) <span class="ot">=&gt;</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  (h es <span class="ot">-&gt;</span> t) <span class="ot">-&gt;</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  h e <span class="ot">-&gt;</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>  t</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>operationFrom f <span class="ot">=</span> f <span class="op">.</span> mapHandle</span></code></pre></div>
<h2 id="acknowledgements">Acknowledgements</h2>
<ul>
<li><p>Ömer, for writing the original article</p></li>
<li><p>Enes Bayram, for <a href="https://old.reddit.com/r/haskell/comments/1fzy3fa/oop_is_not_that_bad_actually/lr55hko/">suggesting the approach of this article on Haskell
Reddit</a></p></li>
</ul>
</div>
<hr>

  </div>

<!-- End Document
================================================== -->
</body>
</html>
